# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Flight Planner H - using data from the Drone's camera sensors
                                 A QGIS plugin
 Flight Planner H
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-05
        copyright            : (C) 2024 by Prof Cazaroli e Leandro França (Professor Ilton contributed to the project)
        email                : contato@geoone.com.br
***************************************************************************/
"""

__author__ = 'Prof Cazaroli and Leandro França (Professor Ilton contributed to the project)'
__date__ = '2024-11-05'
__copyright__ = '(C) 2024 by Prof Cazaroli and Leandro França (Professor Ilton contributed to the project)'
__revision__ = '$Format:%H$'

# PlanoVoo_H_Grid.py
# Duplicate of PlanoVoo_H_Sensor.py adapted for grid flight paths

from qgis.core import (
    QgsProcessingAlgorithm,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterNumber,
    QgsProcessingParameterFeatureSink,
    QgsFeature,
    QgsGeometry,
    QgsPointXY,
    QgsWkbTypes
)
import processing
import math


class PlanoVoo_H_Grid(QgsProcessingAlgorithm):
    INPUT = "INPUT"
    SPACING = "SPACING"
    ALTITUDE = "ALTITUDE"
    OUTPUT = "OUTPUT"

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                "Area of Interest"
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.SPACING,
                "Flight Line Spacing (m)",
                type=QgsProcessingParameterNumber.Double,
                defaultValue=20.0
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.ALTITUDE,
                "Flight Altitude (m)",
                type=QgsProcessingParameterNumber.Double,
                defaultValue=50.0
            )
        )

    def name(self):
        return "planovoo_h_grid"

    def displayName(self):
        return "PlanoVoo H - Grid"

    def group(self):
        return "Drone Flight Paths"

    def groupId(self):
        return "drone_flight_paths"

    def shortHelpString(self):
        return "Generates a grid (crosshatch) flight path for a given AOI."

    def processAlgorithm(self, parameters, context, feedback):
        source = self.parameterAsSource(parameters, self.INPUT, context)
        spacing = self.parameterAsDouble(parameters, self.SPACING, context)
        altitude = self.parameterAsDouble(parameters, self.ALTITUDE, context)

        if source is None:
            raise Exception("Invalid input AOI")

        features = list(source.getFeatures())
        if not features:
            raise Exception("No features in AOI layer")

        aoi_geom = QgsGeometry.unaryUnion([f.geometry() for f in features])

        # Build reference line (bounding box edge)
        bbox = aoi_geom.boundingBox()
        p1 = QgsPointXY(bbox.xMinimum(), bbox.yMinimum())
        p2 = QgsPointXY(bbox.xMaximum(), bbox.yMinimum())
        ref_line = QgsGeometry.fromPolylineXY([p1, p2])

        # Generate grid waypoints
        waypoints = generate_grid_waypoints(aoi_geom, ref_line, spacing, altitude)

        # Output waypoints as point features
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            source.fields(),
            QgsWkbTypes.Point,
            source.sourceCrs()
        )

        for wp in waypoints:
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(wp['x'], wp['y'])))
            feat.setAttributes([wp['seq'], wp['z']])
            sink.addFeature(feat, QgsFeatureSink.FastInsert)

        return {self.OUTPUT: dest_id}


# ============================================================
# GRID WAYPOINT GENERATOR
# ============================================================
def generate_grid_waypoints(aoi_geom, ref_line_geom, spacing, flight_alt, duplicate_tol=0.5):
    def offset_and_clip(reference_line_geom, spacing):
        bbox = aoi_geom.boundingBox()
        diag_len = math.hypot(bbox.width(), bbox.height())
        n_offsets_each_side = int(math.ceil(diag_len / spacing)) + 2

        offset_geoms = []
        for i in range(-n_offsets_each_side, n_offsets_each_side + 1):
            current_dist = i * spacing
            params = {
                'INPUT': reference_line_geom,
                'DISTANCE': current_dist,
                'SEGMENTS': 5,
                'JOIN_STYLE': 0,
                'MITER_LIMIT': 2,
                'OUTPUT': 'memory:'
            }
            try:
                res = processing.run("native:offsetline", params)
            except Exception:
                res = processing.run("native:arrayoffsetlines", params)
            out_layer = res.get('OUTPUT')
            if out_layer:
                for feat in out_layer.getFeatures():
                    g = feat.geometry()
                    if g and not g.isEmpty():
                        clipped = g.intersection(aoi_geom)
                        if clipped and not clipped.isEmpty() and clipped.type() == QgsWkbTypes.LineGeometry:
                            offset_geoms.append(clipped)
        return offset_geoms

    # Perpendicular sweep
    centroid = ref_line_geom.centroid().asPoint()
    perp_geom = QgsGeometry(ref_line_geom)
    perp_geom.rotate(90.0, centroid)

    lines_A = offset_and_clip(ref_line_geom, spacing)
    lines_B = offset_and_clip(perp_geom, spacing)

    def lines_to_waypoints(lines, altitude):
        wps = []
        for line in lines:
            try:
                vertices = [QgsPointXY(p) for p in line.vertices()]
            except Exception:
                vertices = []
                for part in line.asMultiPolyline():
                    for p in part:
                        vertices.append(QgsPointXY(p))
            if not vertices:
                continue
            for p in vertices:
                wps.append((p.x(), p.y(), altitude))
        return wps

    wps_A = lines_to_waypoints(lines_A, flight_alt)
    wps_B = lines_to_waypoints(lines_B, flight_alt)

    def dedupe_waypoints(wps_master, wps_to_filter, tol):
        kept = []
        for x, y, z in wps_to_filter:
            duplicate = False
            for xm, ym, zm in wps_master:
                if math.hypot(xm - x, ym - y) <= tol:
                    duplicate = True
                    break
            if not duplicate:
                kept.append((x, y, z))
        return kept

    merged = []
    merged.extend(wps_A)
    if wps_A and wps_B:
        merged.append(wps_B[0])
        merged.extend(dedupe_waypoints(merged, wps_B[1:], duplicate_tol))
    else:
        merged.extend(wps_B)

    mission_waypoints = []
    for idx, (x, y, z) in enumerate(merged):
        mission_waypoints.append({
            'seq': idx + 1,
            'x': x,
            'y': y,
            'z': z,
            'speed': 5.0,
            'action': 0
        })
    return mission_waypoints
